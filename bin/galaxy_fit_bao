#!/usr/bin/env python

import sys
import argparse
import os
import numpy as np 

from galaxy_bao_fitter import *
from cf_tools import Multipoles

parser = argparse.ArgumentParser()

parser.add_argument('-i', '--input', help='Input correlation function')
parser.add_argument('-c', '--cov', help='Input covariance matrix')
parser.add_argument('-o', '--output', help='Root for outputs')
parser.add_argument('--nmocks', 
                    help='Number of mocks used to compute covariance matrix',
                    type=int)
parser.add_argument('--z', help='Redshift of power spectrum', \
                    type=float, default=0.71)
parser.add_argument('--not_norm_pk', 
                    help='Do NOT normalize the power spectrum to integral one',
                    action='store_true', default=False)
parser.add_argument('--non_linear_pk', 
                    help='Compute non-linear P(k) using CAMB Halofit', 
                    action='store_true', default=False)
parser.add_argument('--cosmology',
                    help='Name of cosmological parameters. Examples: '+
                    'challenge, qpm, planck, outerim', default='challenge')
parser.add_argument('--rmin', help='Minimum separation', 
                    type=float, default=30.)
parser.add_argument('--rmax', help='Maximum separation', 
                    type=float, default=180.)
parser.add_argument('--fit_bb', help='Use broadband', \
                    action='store_true', default=False)
parser.add_argument('--bb_min', help='Minimum exponent for broadband', \
                    type=int, default=-2)
parser.add_argument('--bb_max', help='Maximum exponent for broadband', \
                    type=int, default=0)
parser.add_argument('--fit_nopeak', help='Perform a fit without bao peak', \
                    action='store_true', default=False)
parser.add_argument('--fit_quad', help='Use quadrupole', \
                    action='store_true', default=False)
parser.add_argument('--fit_iso', help='Perform isotropic fit', \
                    action='store_true', default=False)
parser.add_argument('--plotit', help='Plot best-fit model', \
                    action='store_true', default=False)
parser.add_argument('--cute', help='Input is in CUTE format', \
                    action='store_true', default=False)
parser.add_argument('--rebin_r', \
                    help='Rebin input correlation function (needs CUTE type input)',
                     type=int)
parser.add_argument('--shift_r', \
                    help='Shifts input correlation function (needs CUTE type input)', \
                    type=int, default=0)
parser.add_argument('--fixes', nargs='+', \
                    help='Set fixed parameters. Usage: parameter1 value1 parameter2 value2')
parser.add_argument('--limits', nargs='+', \
                    help='Set limits of  parameters. Usage: parameter1 lower1 upper1 parameter2 lower2 upper2 ...')
parser.add_argument('--priors', nargs='+', \
    help='Set priors on parameters. Usage: parameter1 mean1 sigma1 parameter2 mean2 sigma2')
parser.add_argument('--minos', nargs='+', \
    help='Compute precise error bars. Usage: parameter1 parameter2 ...')
parser.add_argument('--scan', nargs='+', 
    help='Compute chi2 surface for a list of parameters. '+
         'Usage: parameter1 lower1 upper1 nbins1 ...')
parser.add_argument('--scan2d', nargs='+', 
    help='Compute 2D chi2 surface for a list of parameters. '+
         'Usage: parameter1 lower1 upper1 nbins1 '+
                'parameter2 lower2 upper2 nbins2 ...')
parser.add_argument('--scan_nopeak', nargs='+', 
                    help='Compute chi2 surface for a list of parameters '+
                         'for a model without BAO peak.'+
                         ' Usage: parameter1 lower1 upper1 nbins1 ...')

parser.add_argument('--scale_cov', type=float, default=1.0, \
                    help='Scale factor for the covariance matrix')

args = parser.parse_args()

argnames = np.sort(np.array([arg for arg in args.__dict__]))
for arg in argnames:
    print(arg, ':', args.__dict__[arg])


z=args.z
rmin=args.rmin
rmax=args.rmax
rebin_r=args.rebin_r
shift_r=args.shift_r
fit_nopeak=args.fit_nopeak
fit_broadband=args.fit_bb
fit_quad=args.fit_quad
fit_iso=args.fit_iso
plotit=args.plotit
nmocks=args.nmocks
fixes=args.fixes
limits=args.limits
priors=args.priors
scale_cov=args.scale_cov
norm_pk = (args.not_norm_pk  == False)




m = Multipoles(args.input, rebin_r=rebin_r, shift_r=shift_r, \
               multipoles=(args.cute==False))
m.read_cov(args.cov)
m.coss *= scale_cov


output = args.output+\
        '-rmin%.1f-rmax%.1f'%(rmin, rmax)+\
        '-nobb'*(1-fit_broadband)+ \
        '-monoonly'*(1-fit_quad)+\
        '-iso'*(fit_iso)
output_base = os.path.basename(output)

if fixes:
    fixes_dict = {}
    for i in range(0, len(fixes), 2):
        fixes_dict[fixes[i]] = float(fixes[i+1])
    fixes=fixes_dict
else:
    fixes={}

if priors:
    priors_dict = {}
    for i in range(0, len(priors), 3):
        priors_dict[priors[i]] = [float(priors[i+1]), float(priors[i+2])]
    priors = priors_dict
else:
    priors={}

if limits:
    limits_dict = {}
    for i in range(0, len(limits), 3):
        limits_dict[limits[i]] = [float(limits[i+1]), float(limits[i+2])]
    limits = limits_dict
else:
    limits={}

if fit_quad:
    quad = m.quad
else:
    quad = None

data = Data(m.r, m.mono, m.coss,  quad=quad, 
            nmocks=nmocks, rmax=rmax, rmin=rmin)


model = Model(fit_broadband=fit_broadband, fit_multipoles=fit_quad, 
              name=args.cosmology, norm_pk=norm_pk, non_linear=args.non_linear_pk, 
              z=z, fit_iso=fit_iso, no_peak=0, 
              bb_min=args.bb_min, bb_max=args.bb_max)

chi2 = Chi2(data=data, model=model)
chi2.fit(fixes=fixes, priors=priors, limits=limits) 
chi2.export(output+'.pars')

if fit_quad:
    fout=open(output+'.at.ap.cov', 'w')
    print(chi2.covariance['at', 'ap']/(chi2.errors['at']*chi2.errors['ap']), file=fout)
    fout.close()


if fit_nopeak:
    model_nopeak = Model(fit_broadband=fit_broadband, 
                         fit_multipoles=fit_quad,
                         name=args.cosmology, norm_pk=norm_pk, 
                         non_linear=args.non_linear_pk, 
                         z=z, fit_iso=fit_iso, no_peak=1)  
    chi2_nopeak = Chi2(data=data, model=model_nopeak)
    chi2_nopeak.fit(fixes=fixes, priors=priors, limits=limits)
    chi2_nopeak.export(output+'-nopeak.pars')


#-- minos (assymetric error bars)
if args.minos:
    for par in args.minos:
        print('Performing minos for', par)
        minos = chi2.mig.minos(var=par)
        fout = open(output+'.%s.minos'%par, 'w')
        print(par, minos[par]['min'], minos[par]['lower'], 
               minos[par]['upper'], minos[par]['is_valid'], file=fout)
        fout.close()


#-- doing chi2 scans
if args.scan:
    for i in range(0, len(args.scan), 4):
        par = args.scan[i]
        low = float(args.scan[i+1])
        upp = float(args.scan[i+2])
        nbin =  int(args.scan[i+3])
        par_scan, chi2_scan = \
            chi2.scan(par_name=par, par_nsteps=nbin, par_min=low, par_max=upp)

        #-- chi2 scans
        fout = open(output+'.%s.scan'%par, 'w')
        print(chi2.best_pars[par], chi2.chi2min, file=fout)
        for i in range(par_scan.size):
            print( par_scan[i], chi2_scan[i], file=fout)
        fout.close()
        print('chi2 scan exported to:', output+'.%s.scan'%par)

if args.scan2d:

    for i in range(0, len(args.scan2d), 8):
        par_names = [args.scan2d[i], args.scan2d[i+4]]
        low = [float(args.scan2d[i+1]), float(args.scan2d[i+5])]
        upp = [float(args.scan2d[i+2]), float(args.scan2d[i+6])]
        nbin =  [int(args.scan2d[i+3]), int(args.scan2d[i+7])]
        par_scan0, par_scan1, chi2_scan = \
            chi2.scan_2d(par_names=par_names, par_nsteps=nbin, par_min=low, par_max=upp)

        #-- chi2 scans
        filename = output+'.%s.%s.scan2d'%(par_names[0], par_names[1])
        fout = open(filename, 'w')
        print( chi2.best_pars[par_names[0]], \
               chi2.best_pars[par_names[1]], \
               chi2.chi2min, file=fout)
        for i in range(par_scan0.size):
            for j in range(par_scan1.size):
                print(par_scan0[i], par_scan1[j], chi2_scan[i, j], file=fout)
        fout.close()
        print('chi2 scan exported to:', filename)

if args.scan_nopeak:

    for i in range(0, len(args.scan_nopeak), 4):
        par = args.scan_nopeak[i]
        low = float(args.scan_nopeak[i+1])
        upp = float(args.scan_nopeak[i+2])
        nbin =  int(args.scan_nopeak[i+3])
        par_scan_nopeak, chi2_scan_nopeak = \
            chi2_nopeak.scan(par_name=par, par_nsteps=nbin, par_min=low, par_max=upp)

        #-- chi2 scans
        fout = open(output+'-nopeak.%s.scan'%par, 'w')
        print(chi2_nopeak.best_pars[par], chi2_nopeak.chi2min, file=fout)
        for i in range(par_scan_nopeak.size):
            print(par_scan_nopeak[i], chi2_scan_nopeak[i], file=fout)
        fout.close()


if plotit:
    P.figure()
    chi2.plot_bestfit(label=r'$\chi^2 = %.2f$'%chi2.chi2min)
    if fit_nopeak:
        chi2_nopeak.plot_bestfit(model_only=1, \
                label=r'$\chi^2_{\rm no \ peak} = %.2f$'%chi2_nopeak.chi2min)
    if fit_quad:
        P.subplot(211)
    P.legend(loc=0)
    P.show()
    #if save:
    #    savefig('plots/bestfit-%s.pdf'%output_base, bbox_inches='tight')








